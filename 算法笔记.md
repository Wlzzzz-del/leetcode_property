# 快速排序
## 算法思想
1. 设定数组中的任意元素为pivot,
2. 将所有大于pivot的数移到右边
3. 将所有小于pivot的数移到左边
4. 以pivot的两侧子数组递归调用以上三步

## 容易不理解的点
关键在与pivot在交替排序之前就取出来了，因此数组内空了一个位置，
在交替扫描时遇到不符合的数字就放到空位置，直至左右指针重合。

## 代码
``` C++
void quick_sort(std::vector<int> vec, int begin, int end)
{
    if(begin < end)// 递归跳出的条件
    {
        int l = begin;
        int r = end;
        int pivot = vec[l];// 使数组空出一个位置,很重要
        while(l<r)
        {
            while(l<r && pivot< vec[r])
            r--;
            vec[l] = vec[r];
            while(l<r && pivot> vec[l])
            l++;
            vec[r] = vec[l]
        }
        vec[l] = pivot;
        quick_sort(vec, begin, l-1);// 递归调用左端
        quick_sort(vec, l+1, end);// 递归调用右端
    }
}
```

# 广度优先搜索
## 有关定理
无权重无向图通过bfs找到的路径一定是最短路径。

## 单源广度优先搜索
单一节点开始的bfs

## 多源广度优先搜索
多个节点齐头并进的bfs,与单源bfs的不同在于：多源bfs首次有多个元素入队。
经典例题:[1765.地图中的最高点](https://leetcode.cn/problems/map-of-highest-peak/)/[题解代码](1765_highestPeak.cpp)

## 状态压缩+bfs
状态压缩用二进制数表示遍历中的某种状态。由于数组占用空间较大,而且在算法中不好传递参数。
假设某无向图中有三个节点，分别为0\1\2。当0\1节点已经被遍历过了，此时的状态数可以表示为 ***011(二进制)=3(十进制)*** .

假设图中有n个节点，则状态数可以如下表示：

### 某个节点被访问的状态累加
当访问到某个节点时，对状态数进行记录：
```C++
    int status=0;// 假设0为初始状态
    int node;// 当前访问到的节点
    status = status|(1>>node);// 记录
```
### 遍历完成状态数
遍历完成状态数用于判断是否所有的节点都已经被访问过：
```C++
    int end = pow(2,n)-1;
```
判断是否已经全部访问：
```C++
    if(end == status)somecode;
```
### 例题
[847. 访问所有节点的最短路径](https://leetcode.cn/problems/shortest-path-visiting-all-nodes/comments/)/
[题解代码](847_shortestPathLength.cpp)

# 线段树
## 线段树定义
线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树的一小个节点。
使用线段树可以快速查找某一个节点在若干线段中出现的次数，时间复杂度为O(logN).
## 实现代码
[线段树的实现](segement_tree.cpp)

## 动态开点
## 离散化
## 例题
[729.我的日程表安排Ⅰ](https://leetcode.cn/problems/my-calendar-i/solution/by-ac_oier-hnjl/)

